/*
 * Cube Mendelev HTTP API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: support@cube.exchange
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`book_market_id_recent_trades_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BookMarketIdRecentTradesGetError {
    Status500(models::BookMarketIdSnapshotGet500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`book_market_id_snapshot_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BookMarketIdSnapshotGetError {
    Status500(models::BookMarketIdSnapshotGet500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`parsed_book_market_symbol_recent_trades_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParsedBookMarketSymbolRecentTradesGetError {
    Status500(models::BookMarketIdSnapshotGet500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`parsed_book_market_symbol_snapshot_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParsedBookMarketSymbolSnapshotGetError {
    Status500(models::BookMarketIdSnapshotGet500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`parsed_tickers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ParsedTickersGetError {
    Status500(models::BookMarketIdSnapshotGet500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tickers_snapshot_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TickersSnapshotGetError {
    Status500(models::BookMarketIdSnapshotGet500Response),
    UnknownValue(serde_json::Value),
}


pub async fn book_market_id_recent_trades_get(configuration: &configuration::Configuration, market_id: &str) -> Result<models::BookMarketIdRecentTradesGet200Response, Error<BookMarketIdRecentTradesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/book/{market_id}/recent-trades", local_var_configuration.base_path, market_id=crate::apis::urlencode(market_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BookMarketIdRecentTradesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn book_market_id_snapshot_get(configuration: &configuration::Configuration, market_id: &str, mbp: Option<bool>, mbo: Option<bool>, levels: Option<i32>) -> Result<models::BookMarketIdSnapshotGet200Response, Error<BookMarketIdSnapshotGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/book/{market_id}/snapshot", local_var_configuration.base_path, market_id=crate::apis::urlencode(market_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = mbp {
        local_var_req_builder = local_var_req_builder.query(&[("mbp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = mbo {
        local_var_req_builder = local_var_req_builder.query(&[("mbo", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = levels {
        local_var_req_builder = local_var_req_builder.query(&[("levels", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BookMarketIdSnapshotGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn parsed_book_market_symbol_recent_trades_get(configuration: &configuration::Configuration, market_symbol: &str) -> Result<models::ParsedBookMarketSymbolRecentTradesGet200Response, Error<ParsedBookMarketSymbolRecentTradesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/parsed/book/{market_symbol}/recent-trades", local_var_configuration.base_path, market_symbol=crate::apis::urlencode(market_symbol));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ParsedBookMarketSymbolRecentTradesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn parsed_book_market_symbol_snapshot_get(configuration: &configuration::Configuration, market_symbol: &str, depth: Option<i32>) -> Result<models::ParsedBookMarketSymbolSnapshotGet200Response, Error<ParsedBookMarketSymbolSnapshotGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/parsed/book/{market_symbol}/snapshot", local_var_configuration.base_path, market_symbol=crate::apis::urlencode(market_symbol));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = depth {
        local_var_req_builder = local_var_req_builder.query(&[("depth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ParsedBookMarketSymbolSnapshotGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn parsed_tickers_get(configuration: &configuration::Configuration, ) -> Result<models::ParsedTickersGet200Response, Error<ParsedTickersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/parsed/tickers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ParsedTickersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn tickers_snapshot_get(configuration: &configuration::Configuration, ) -> Result<models::TickersSnapshotGet200Response, Error<TickersSnapshotGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/tickers/snapshot", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TickersSnapshotGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

